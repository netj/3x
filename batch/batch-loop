#!/usr/bin/env bash
# batch-loop -- The loop that handles a batch
# Usage: export EXPBATCH; cd $EXPROOT/$EXPBATCH; batch-loop
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2013-01-17
set -eu

synchronized() {
    local Lock=$1; shift
    until lockproc $Lock grab; do sleep 1; done
    "$@"
    lockproc $Lock release
}

# prepare a remaining queue based on the plan
if ! [ -e remaining -a -s count -a -d runs ]; then
    initialize() {
        msg "Initializing $EXPBATCH"
        # append serial numbers to each line unless all lines already have one
        if grep -q -v '#[0-9]+$' <plan; then
            mv -f plan plan.orig
            sed 's/#.*//' <plan.orig >plan
            serialOnEachLine plan >remaining
        else
            cat plan >remaining
        fi
        chmod a-w plan
        wc -l <plan >count
        mkdir -p runs
    }
    synchronized remaining.lock  initialize
fi
if ! [ -s remaining ] && [[ $(find running.*/cmdln 2>/dev/null | wc -l) == 0 ]]; then
    rm -rf running.*/
    msg "Nothing remaining for $EXPBATCH"
    exit 2
fi

# register worker pid
workerHandle=
register-pid() {
    local id=0
    local handle=
    while handle=worker-"$id".lock
        lockproc $handle alive
    do let ++id
    done
    lockproc $handle grab
    workerHandle=$handle
}
synchronized workers.lock register-pid

# repeat until all "remaining" runs are done
msg "Starting $EXPBATCH"
count=$(cat count || wc -l <plan)
abort=false
trap "abort=true" TERM INT
while [ -s remaining ] && ! $abort; do
    run=
    pick-next() {
        # check if there's any running item which isn't alive
        for r in running.*/; do
            [ -d "$r" ] || continue
            [ -s "$r"/cmdln ] || continue
            ! lockproc $r/lock alive || continue
            lockproc $r/lock grab || continue
            msg +2 " resuming $r..."
            run=$r; break
        done
        # otherwise, dequeue from remaining
        if ! [ -d "$run" ]; then
            run=$(mktemp -d running.XXX)
            lockproc $run/lock grab || continue
            head -n 1 remaining >$run/cmdln
            { echo 1d; echo wq; } | ed remaining &>/dev/null
        fi
    }
    synchronized remaining.lock  pick-next || continue
    # run the one we picked for next
    line=$(cat $run/cmdln)
    serial=${line##*"#"}
    cmdln=${line%"#"*}
    EXPRUN=$(new-run-id)
    runRelPath="../../../${EXPRUN#run/}"
    msg "Batch #$serial/$count of $EXPBATCH as $EXPRUN"
    ln -sfn "$runRelPath" $run/run
    EXPRUN=$EXPRUN $cmdln || true
    ! $abort || break
    # after it ends, record the run in the "done" queue
    record() {
        ln -sfn "$runRelPath" runs/$serial
        echo "$line" >>"done"
    }
    synchronized done.lock  record
    rm -rf "$run"
    #lockproc $run/lock release || true # no need to release the removed lock
done

# unregister worker pid
lockproc $workerHandle release

if $abort; then
    error "Aborted $EXPBATCH" || true
    msg "To resume, run:"
    msg "  exp start $EXPBATCH"
    exit 2
else
    msg "Done $EXPBATCH"
fi
