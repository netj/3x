#!/usr/bin/env bash
# exp-assemble -- assemble an experiment with given parameters
# Usage: exp assemble OUTPUTDIR [NAME=VALUE]...
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2012-11-01
set -eu

[ $# -ge 1 ] || usage "$0" "At least OUTPUTDIR must be given"

EXPWD=$1; shift

EXPROOT=$(exp-findroot)

# create the OUTPUTDIR with a working directory
mkdir -p "$EXPWD"/workdir

# decide some important environment values
EXPWD=$(readlink -f "$EXPWD")
: ${EXPRUN:=${EXPWD#$EXPROOT/}}
export EXPROOT EXPRUN EXPWD
cd "$EXPROOT"

# prepare the assemble script
update-assemble-script() {
    local scpt=$1; shift
    if ! [ -s "$scpt" ] ||
        find "$0" $(type -p generate-assembly-script) "$@" -newer "$scpt" | read; then
        msg "Updating $scpt"
        rm -f "$scpt"
        EXPWD=$EXPWD \
            generate-assembly-script "$@" >"$scpt"
        screen -m -D vim -n "$scpt" +"set ft=sh" +"norm gg=G" +wq &>/dev/null || true
    fi
}
assembleScript=.exp/assemble.sh
update-assemble-script $assembleScript program condition/*=* measure/*/*=*

# assemble the conditions for experiment
msg "Assembling $EXPRUN for $*"
: >"$EXPWD"/assembly
(
    # override some commands used in the assembly script
    error() {
        command error "$@"
        touch "$EXPWD"/assembly.error
    }
    source() {
        # replace source with our function that avoids any evaluation in the definitions
        local f=$1
        ! grep -qF "${f%/env}" "$EXPWD"/assembly || return 0
        local decl= v= l=1
        while read -r decl; do
            decl=${decl%%*([ 	])#*}
            [ -n "$decl" ] || continue
            v=${decl%%=*}
            ! declare -p $v &>/dev/null || error "$f: line $l: $v: duplicate variable"
            export "$decl"
            declare -r $v
            let l++
        done <"$f"
    }

    # record environment variables
    envFiles=(condition/env.default)
    if [ $(no-comments "${envFiles[@]}" | wc -l) -gt 0 ]; then
        envVarNames=$(list-var-names "${envFiles[@]}")
        msg +1 " recording environment as per ${envFiles[*]}: "$envVarNames
        {
            export -- $(no-comments "${envFiles[@]}")
            for v in $envVarNames; do echo "$v=${!v}"; done >"$EXPWD"/env
            declare -r $envVarNames
        } >/dev/null
    fi

    # record condition variables, so they can populate the environment
    for param in "$@"; do echo "$param"; done >>"$EXPWD"/env
    be-quiet +3 || set -x
    declare -r "$@"

    # repeat iterations with assembly script until no change
    assemble-iteration() {
        wc -l <"$EXPWD"/assembly >"$EXPWD"/assembly.in-progress
        builtin source "$assembleScript"
        [ $(wc -l <"$EXPWD"/assembly) -eq $(cat "$EXPWD"/assembly.in-progress) ]
    }
    while ! assemble-iteration; do :; done
    rm -f "$EXPWD"/assembly.in-progress
)

# check if assembly went ok
[ ! -e "$EXPWD"/assembly.error ]
if ! [ -x "$EXPWD"/workdir/run ]; then
    error "Assembly failed for $EXPRUN: No executable \`run' exists"
fi

# record all condition parameters again in a separate file
for param in "$@"; do echo "$param"; done >"$EXPWD"/condition

# make sure some files exist
cp -af "$assembleScript" "$EXPWD"/assemble.sh
for f in env args stdin; do
    [ -e "$EXPWD/$f" ] || touch "$EXPWD/$f"
done
