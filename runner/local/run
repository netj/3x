#!/usr/bin/env bash
# run -- run an experiment with given parameters
# 
# > run NAME=VALUE [NAME=VALUE]...
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2012-11-01
set -eu

[ $# -ge 1 ] || usage "$0" "At least one NAME=VALUE pairs must be given"

_3X_ROOT=$(3x-findroot)
: ${_3X_RUN:=$(new-run-id)}
export _3X_ROOT _3X_RUN _3X_WD="$_3X_ROOT/$_3X_RUN"
: ${_3X_ARCHIVE:=$_3X_ROOT/.3x/files}

# archive everything when run exits
cleanup() {
    local c=$?
    set +e
    (
    set -e
    cd "$_3X_WD" 2>/dev/null
    msg +2 "Archiving $_3X_RUN to .3x/files/"
    chmod a-w output stdout stderr 2>/dev/null || true
    archive "$_3X_ARCHIVE" . ! -path ./output ! -path ./stdout ! -path ./stderr
    )
    exit $c
}
trap cleanup EXIT

# assemble the run
cd "$_3X_ROOT"
assembleScript=$(update-assembly-script)
msg "Assembling $_3X_RUN for $*"
# figure out environment
envVars=()
envFiles=("${_3X_RUN_ENVIRON:-$TOOLSDIR/runner/local/environ.default}")
if [ $(no-comments "${envFiles[@]}" | wc -l) -gt 0 ]; then
    envVarNames=$(list-var-names "${envFiles[@]}")
    msg +1 " using environment as per ${envFiles[*]}: "$envVarNames
    {
        eval export -- $(no-comments "${envFiles[@]}" | sed 's/\([^=]*\)=\(.*\)/\1=${\1:-\2}/')
        for v in $envVarNames; do
            envVars+=("$v=${!v:-}")
        done
    } >/dev/null
fi
"$assembleScript" "$_3X_WD" "$@" -- "${envVars[@]}" ||
    error "Assembly failed for $_3X_RUN"


# execute it
cd "$_3X_WD"
msg "Running $_3X_RUN with $*"
./execute.sh &
runpid=$!

# watch stdout and stderr
trap "kill -TERM $runpid; wait $runpid" INT QUIT TERM
be-quiet +1 || {
tail -qF stdout --pid=$runpid      2>/dev/null &
tail -qF stderr --pid=$runpid 1>&2 2>/dev/null &
}
wait || true

if [ -e exitcode ]; then
    exitcode=$(cat exitcode)
    msg "Finished $_3X_RUN with exitcode $exitcode"
else
    exitcode=127
    msg "Interrupted $_3X_RUN"
    exit $exitcode
fi

# run output measurements
for mx in measures/*/measure; do
    m=$(basename "$(dirname "$mx")")
    if [ -x "$mx" ]; then
        echo "$m=$(escape-args-for-shell "$(
        # run measure drivers under the same env
        export $(cat ./env) _3X_MEASURE=${mx%/measure}
        "$mx"
        )")"
    fi
done >output

# incrementally update the index with this run
3x-index init
3x-index update .

exit $exitcode
