#!/usr/bin/env bash
# > 3x start
# Starts a new worker for executing runs in current queue.  You can start
# as many workers as you want to execute in parallel.
#
# queue-start -- starts a new worker for current queue
# 
# > . find-runner.sh -
# > setsid queue-start
#
# Along with base queue-stop, workers can be stopped entirely or individually.
# The worker started by this base queue-start stays idle when the plan is
# empty until it gets waken by base queue-changed, so arriving runs at the
# queue can be processed instantly.
# 
# To extend the default behavior of this handler, create queue-start handler
# in the extending runner's directory as follows:
# > . runner.sh [PARENT_RUNNER...]
# > ...             # things to do before
# > super "$0" "$@" # the default behavior, if needed ($PWD MUST remain same)
# > ...             # things to do after
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2013-01-17
set -eu
. runner.sh

# register worker pid
_3X_WORKER_ID=
workerHandle=
register-pid() {
    _3X_WORKER_ID=0
    local handle=
    while handle=$WORKER_LOCK_PREFIX${_3X_WORKER_ID}.lock
        lockproc $handle alive
    do let ++_3X_WORKER_ID
    done
    lockproc $handle grab
    workerHandle=$handle
}
synchronized $WORKER_LOCK_PREFIX.lock register-pid

# mark queue as active
{
    date +"# %FT%T%:z"
    echo "start $*"
} >>$ACTIVE_FLAG

# create a directory for organizing worker-local stuffs
export _3X_WORKER_DIR="$_3X_QUEUE_DIR/$WORKER_DIR_PREFIX$_3X_WORKER_ID"
mkdir -p "$_3X_WORKER_DIR"

# keep a copy of the target execution environment configuration while for this session
cp -a "$_3X_TARGET_DIR"/. "$_3X_WORKER_DIR"/target

# repeat until all planned runs are done
runner-msg "Starting"
processing=false
stopped=false
abort=false
trap "stopped=true abort=true" INT QUIT
trap "stopped=true" TERM
trap '$processing || runner-msg "Resuming"' $WORKER_WAITING_SIGNAL
queue-not-empty() {
    # check if there are planned runs, or interrupted ones in current queue
    if [ -s plan ]; then
        return 0 # = true
    elif [ -s running ]; then
        local lock=
        for lock in $RUNDIR_PREFIX*/lock; do
            [ -e "$lock" ] || continue
            lockproc "$lock" alive || return 0 # = true
        done
    fi
    false
}
until $stopped; do
    if queue-not-empty; then
        # process runs in the current queue
        processing=true
        let SHLVL--
        dequeue || true
        let ++SHLVL
        processing=false
    fi
    # wait for plan to become non-empty
    until $stopped || queue-not-empty; do
        runner-msg "Waiting"
        touch $workerHandle$WORKER_WAITING_SUFFIX
        sleep $WORKER_WAITING_TIMEOUT &>/dev/null || true
    done
    rm -f $workerHandle$WORKER_WAITING_SUFFIX
done

# unregister worker pid
lockproc $workerHandle release

if $abort; then
    runner-error "Aborted" || true
    queue-refresh
    if ! [ -e $ACTIVE_FLAG ]; then
        msg
        msg "# To restart and resume execution, run:"
        msg "3x start"
        msg
        msg "# To fully stop, and put executing runs back to plan, run:"
        msg "3x stop"
    fi
    exit 2
else
    runner-msg "Stopped"
fi
